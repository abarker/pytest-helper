
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pytest-helper &#8212; pytest-helper  documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pytest_helper package" href="pytest_helper.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pytest_helper.html" title="pytest_helper package"
             accesskey="N">next</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">pytest-helper  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pytest-helper">
<h1>pytest-helper<a class="headerlink" href="#pytest-helper" title="Permalink to this headline">¶</a></h1>
<p>The pytest-helper package allows modules, both inside and outside of packages,
to be made self-testing with <a class="reference external" href="http://pytest.org">pytest</a> when the module
itself is executed as a script.  The test functions that are run can be located
in the same module as the code being tested or they can be located in a module
in a separate test directory.  Standalone testing modules can also be easily
set up so that they are self-testing with pytest when they are executed.</p>
<p>Several additional utility functions are provided to make it easier to set up
and run unit tests.  For example, there is a function to simplify making
modifications to the Python search path so that tests are discovered.  One of
the useful features of the package is that relative pathnames are always
interpreted relative to the directory of the file in which they occur (i.e.,
not relative to the Python CWD which can vary depending on how the python
interpreter is invoked).</p>
<p>Two kinds of helper functions are provided.  The first kind are intended to
make it easier to run pytest on a test file or files, and the second kind are
meant to be used in writing tests, inside test files.  Some of the provided
helper functions are general-purpose, but several are specific to the <a class="reference external" href="http://pytest.org">pytest</a> testing framework.  These helper functions are
independent of each other and can be used (or not used) as desired.  The
functions are all compatible with the ordinary uses and invocations of pytest.</p>
<div class="section" id="introduction">
<span id="id2"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Testing is an important part of software development, especially for a
dynamically-typed language like Python.  The easier it is for people to set up
and run tests, the more likely they are to write their tests as they code
rather than waiting until later to do so (or perhaps not writing formal tests
at all).</p>
<p>When developing a Python module it is nice to be able to quickly run some tests
specific to that module, without having to run all the tests for the full
package.  Using pytest-helper it is easy to make files self-testing whenever
they are run as scripts.  During development you can then just run the file,
say from your editor or IDE, to see the test results.</p>
<p>Below is a simple example to illustrate the idea.  This is a Python module
which is possibly part of a larger package.  It contains its own test functions
at the bottom.  Whenever the module is run as a script the tests will be run
with pytest; when the module is imported it runs normally.  So as the module is
being written or modified it can be executed to see the results of tests, and
new tests can be added as you go along.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest_helper</span>

<span class="c1">#</span>
<span class="c1"># Run the tests, but only when the module is invoked as a script.</span>
<span class="c1">#</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>  <span class="c1"># Guard conditional, optional but recommended.</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="n">self_test</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Regular imports and program code go here.</span>
<span class="c1">#</span>

<span class="n">code_var</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>

<span class="c1">#</span>
<span class="c1"># Test functions are below; they can easily be moved to a separate module.</span>
<span class="c1">#</span>

<span class="n">pytest_helper</span><span class="o">.</span><span class="n">autoimport</span><span class="p">()</span>  <span class="c1"># Do some basic imports automatically.</span>

<span class="k">def</span> <span class="nf">my_setup</span><span class="p">():</span>  <span class="c1"># Could be a pytest fixture instead of a regular function.</span>
    <span class="n">setup_var</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
    <span class="n">locals_to_globals</span><span class="p">()</span>  <span class="c1"># Copies setup_var to the module&#39;s global namespace.</span>

<span class="k">def</span> <span class="nf">test_var_values</span><span class="p">():</span>
    <span class="n">my_setup</span><span class="p">()</span>  <span class="c1"># Run the setup code.</span>
    <span class="k">assert</span> <span class="n">code_var</span> <span class="o">==</span> <span class="s2">&quot;foo&quot;</span>  <span class="c1"># Set in the regular code above.</span>
    <span class="k">assert</span> <span class="n">setup_var</span> <span class="o">==</span> <span class="s2">&quot;bar&quot;</span>    <span class="c1"># Copied to the global namespace.</span>
    <span class="n">test_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="n">raises</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>  <span class="c1"># Pytest function raises was autoimported.</span>
        <span class="n">test_dict</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>There are more examples in the <a class="reference internal" href="#examples"><span class="std std-ref">Examples</span></a> section below.  They include the
case where the tests to be run are in separate test files and the case of
making the separate test files themselves self-testing.  It is easy to move
tests originally written inside the module being tested to a separate test
file.</p>
<p>In order to simplify the functional interface, some of these helper functions
use basic introspection look up the names of modules.  Other functions use
introspection to modify a module’s global variables.  Where introspection is
used, a fallback is usually provided to do the task without introspection.
(Some people might object to the use of introspection “magic,” but the level
used by these functions is less than what pytest itself does already.)</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>The easiest way to install is to install from PyPI using pip:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip install pytest-helper
</pre></div>
</div>
<p>Alternately, you can download or clone the repository directory from <a class="reference external" href="https://github.com/abarker/pytest-helper">the
pytest-helper GitHub pages</a> and
then install using either <code class="code docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">.</span></code> or <code class="code docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code> from the
root directory (pip is preferred).  In lieu of installing you can just add the
<code class="code docutils literal notranslate"><span class="pre">pytest_helper/src</span></code> subdirectory to your <code class="code docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> environment variable.</p>
</div>
<div class="section" id="functions-to-help-in-running-tests">
<h2>Functions to help in running tests<a class="headerlink" href="#functions-to-help-in-running-tests" title="Permalink to this headline">¶</a></h2>
<p>These are short descriptions of the functions which simplify the invocation of
pytest on a given test file.  The links go to the more-detailed functional
interface descriptions.</p>
<ul>
<li><p><a class="reference internal" href="pytest_helper.pytest_helper_main.html#script-run"><span class="std std-ref">pytest_helper.script_run</span></a></p>
<blockquote>
<div><p>The <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> function is used to actually invoke pytest on a test file or
list of files.  It takes a path or a list of paths and, when called from a
script, will run pytest on all those files.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> function is useful because it allows Python modules to be
easily made self-testing when they are run as scripts.  When working on a
module in, say, Vim you can invoke a command to run the current file as a
script in order to verify that it still passes whatever tests are defined
for it.  Those tests can be in the same file and/or in other files.  Test
files themselves can similarly be made self-executing when run as a script,
which can be useful when writing tests.</p>
<p>One use of modules with self-contained tests, like in the example in the
<a class="reference internal" href="#introduction"><span class="std std-ref">Introduction</span></a>, is to quickly start writing a simple module while
including a few tests.  As (or if) the module continues to evolve it is easy to
extract those tests into a separate test module at some point.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> is not called from a script’s <code class="code docutils literal notranslate"><span class="pre">__main__</span></code> module then it
returns without doing anything.  Any relative paths passed to the function
are expanded relative to the directory of the module from which the
<code class="code docutils literal notranslate"><span class="pre">script_run</span></code> function is called.</p>
<p>The example in the <a class="reference internal" href="#introduction"><span class="std std-ref">Introduction</span></a> shows how to use <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> to run
a self-test on a file.  The line below shows how the <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> function
would be used to run pytest, with the <code class="code docutils literal notranslate"><span class="pre">-v</span></code> verbose argument, on a test
file named <code class="code docutils literal notranslate"><span class="pre">test/test_foobar.py</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="s2">&quot;test/test_foobar.py&quot;</span><span class="p">,</span> <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>When the module that calls the above function is not run as a script the
function call does nothing.</p>
<p>If the pytest option <code class="code docutils literal notranslate"><span class="pre">--pyargs</span></code> is used to include dotted Python package
descriptors you should also use the <code class="code docutils literal notranslate"><span class="pre">pyargs=True</span></code> option to <code class="code docutils literal notranslate"><span class="pre">script_run</span></code>.
Setting the pytest-helper argument automatically passes the argument to
pytest.</p>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="pytest_helper.pytest_helper_main.html#sys-path"><span class="std std-ref">pytest_helper.sys_path</span></a></p>
<blockquote>
<div><p>The function <code class="code docutils literal notranslate"><span class="pre">sys_path</span></code> takes a directory path or a list of paths and
inserts them into Python’s <code class="code docutils literal notranslate"><span class="pre">sys.path</span></code> list.  This is often necessary in
order for Python to find the imports in test files.  A benefit of using this
function is that relative paths are allowed, and all relative paths are
expanded relative to the directory of the module which calls the function.
This is in contrast to the default evaluation of relative paths in Python,
which is relative to Python’s current working directory (CWD).  The CWD can
vary depending on the particular command used to invoke the Python
interpreter.  Using relative imports within a project’s directory structure
makes it more portable.</p>
<p>The line below shows how to use <code class="code docutils literal notranslate"><span class="pre">sys_path</span></code> to add both the directory
<code class="code docutils literal notranslate"><span class="pre">../test</span></code> and the parent directory to Python’s <code class="code docutils literal notranslate"><span class="pre">sys.path</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytest_helper</span><span class="o">.</span><span class="n">sys_path</span><span class="p">(</span><span class="s2">&quot;../test&quot;</span><span class="p">,</span> <span class="n">add_parent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This line does the same thing as the line above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytest_helper</span><span class="o">.</span><span class="n">sys_path</span><span class="p">([</span><span class="s2">&quot;..&quot;</span><span class="p">,</span> <span class="s2">&quot;../test&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="pytest_helper.pytest_helper_main.html#init"><span class="std std-ref">pytest_helper.init</span></a></p>
<blockquote>
<div><p>Calling the <code class="code docutils literal notranslate"><span class="pre">pytest_helper.init</span></code> function is optional, but sometimes it is
useful.  This function should be called directly after importing
<code class="code docutils literal notranslate"><span class="pre">pytest_helper</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest_helper</span>
<span class="n">pytest_helper</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
</pre></div>
</div>
<p>The main benefit of using an early <code class="code docutils literal notranslate"><span class="pre">init</span></code> call is to make sure that the
introspective lookup of the calling-module’s path continues to work even if
some intervening command or module import changes the Python CWD (which is
rare, but it happens).  This function can also be used to disable the use of
configuration files (<a class="reference internal" href="#configuration"><span class="std std-ref">see below</span></a>).</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="functions-to-help-in-writing-tests">
<h2>Functions to help in writing tests<a class="headerlink" href="#functions-to-help-in-writing-tests" title="Permalink to this headline">¶</a></h2>
<p>These convenience functions are used to help in writing the tests themselves.
They are good for quickly setting up tests.  They can always be replaced by
their more-conventional (non-magic) equivalents.</p>
<ul>
<li><p><a class="reference internal" href="pytest_helper.pytest_helper_main.html#locals-to-globals"><span class="std std-ref">pytest_helper.locals_to_globals</span></a></p>
<blockquote>
<div><p>The <code class="code docutils literal notranslate"><span class="pre">locals_to_globals</span></code> function is intended to be run from a fixture (i.e.,
from a test setup function) in the same module as the tests.  It mimics the
effect of declaring all the local variables in the setup function global in
order to access them from the test functions that use the setup.  By default
it never overwrites an existing global variable unless that variable was set
by a previous run of <code class="code docutils literal notranslate"><span class="pre">locals_to_globals</span></code>.  Can optionally clear any
variables set on previous calls so that they do not accidentally affect the
current tests.</p>
<p>This function is usually called without arguments, near the end of a setup
function or fixture.  If <code class="code docutils literal notranslate"><span class="pre">autoimport</span></code> is used then it is automatically
imported into the module’s global namespace.</p>
<p>Note that some linters will complain about variables being used without
being set.</p>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="pytest_helper.pytest_helper_main.html#clear-locals-from-globals"><span class="std std-ref">pytest_helper.clear_locals_from_globals</span></a></p>
<blockquote>
<div><p>The <code class="code docutils literal notranslate"><span class="pre">clear_locals_from_globals</span></code> function is called by <code class="code docutils literal notranslate"><span class="pre">locals_to_globals</span></code>
when <code class="code docutils literal notranslate"><span class="pre">clear</span></code> is set true.  This function can also be explicitly called to do
the clearing.</p>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="pytest_helper.pytest_helper_main.html#autoimport"><span class="std std-ref">pytest_helper.autoimport</span></a></p>
<blockquote>
<div><p>The <code class="code docutils literal notranslate"><span class="pre">autoimport</span></code> function is a convenience function that automatically
imports certain pytest-helper and pytest functions into the calling module’s
global namespace.  The names can then be used essentially as builtins in the
test code.  By default an exception is raised if the imports shadow any
existing variables.</p>
<p>This function imports the <code class="code docutils literal notranslate"><span class="pre">pytest</span></code> module as <code class="code docutils literal notranslate"><span class="pre">pytest</span></code>.  From pytest-helper
it imports <code class="code docutils literal notranslate"><span class="pre">locals_to_globals</span></code>, <code class="code docutils literal notranslate"><span class="pre">clear_locals_from_globals</span></code>, and <code class="code docutils literal notranslate"><span class="pre">unindent</span></code>.
From pytest it imports <code class="code docutils literal notranslate"><span class="pre">raises</span></code>, <code class="code docutils literal notranslate"><span class="pre">fail</span></code>, <code class="code docutils literal notranslate"><span class="pre">fixture</span></code>, <code class="code docutils literal notranslate"><span class="pre">skip</span></code>, <code class="code docutils literal notranslate"><span class="pre">xfail</span></code>, and
<code class="code docutils literal notranslate"><span class="pre">approx</span></code>.</p>
<p>This function is usually called without arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytest_helper</span><span class="o">.</span><span class="n">autoimport</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that some linters will complain about variables being used without
being set.</p>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="pytest_helper.pytest_helper_main.html#unindent"><span class="std std-ref">pytest_helper.unindent</span></a></p>
<blockquote>
<div><p>The <code class="code docutils literal notranslate"><span class="pre">unindent</span></code> function allows for cleaner formatting of multi-line strings,
for example to compare with in a pytest assertion.  The first argument,
<code class="code docutils literal notranslate"><span class="pre">unindent_level</span></code>, gives the number of characters to unindent.  The second
argument is the string (typically a triple-quote string).  The string is
split into lines, keeping all empty lines, and then the first and last line
are discarded.  Each line is then unindented by the <code class="code docutils literal notranslate"><span class="pre">unindent_level</span></code> argument
number of characters, and the lines are re-joined with newlines.  An exception
is raised on trying to unindent non-whitespace on a line or if there are
fewer than two lines.</p>
<p>Here is a simple example usage, comparing a parse result with an expression
tree of tokens in a multi-line string.  The assertion is assumed
to be inside a pytest testing function, already indented four
spaces.  The parse result is assumed to start on the first column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">result_tree</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">()</span> <span class="o">==</span> <span class="n">unindent</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &lt;k_plus,&#39;+&#39;&gt;</span>
<span class="s2">            &lt;k_identifier,&#39;x&#39;&gt;</span>
<span class="s2">            &lt;k_float,&#39;0.22&#39;&gt;</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="examples">
<span id="id3"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#introduction"><span class="std std-ref">Introduction</span></a> gives an example of a self-testing module, which
contains both the code to be tested as well as pytest test functions for that
code.  Below are some examples of using the pytest-helper functions in other
common cases.</p>
<p>Whenever <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> is called from a module to run tests it is best to call
it from the beginning of the file, especially for files inside packages which
do intra-package imports.  This placement is more efficient and avoids some
potential headaches with imports.  I like to put the import of pytest-helper
and the call to <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> directly after any <code class="code docutils literal notranslate"><span class="pre">__future__</span></code> import and before
all the others, but it really just needs to be before any imports which use
intra-package imports (since the module is being run as a script when
<code class="code docutils literal notranslate"><span class="pre">script_run</span></code> executes).</p>
<p>Whenever <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> is called in the examples below the optional <code class="code docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span>
<span class="pre">==</span> <span class="pre">&quot;__main__&quot;</span></code> guard conditional is used.  It can be left off, but it is
slightly more efficient to use it since without it the module’s name has to be
looked up by introspection to see if anything should be done.  Using the
conditional also makes the code more explicit in what it is doing.</p>
<ul>
<li><p><strong>Running tests contained in separate test files and test directories.</strong></p>
<blockquote>
<div><p>This is an example of a module with its tests in separate test files and
directories.  When invoked as a script it the module will run all the tests
in the subdirectory <code class="code docutils literal notranslate"><span class="pre">test</span></code> and then run only the test file <code class="code docutils literal notranslate"><span class="pre">test_var_set.py</span></code>
in a sibling-level test directory called <code class="code docutils literal notranslate"><span class="pre">test2</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
<span class="c1"># Run the specified test files, but only when invoked as a script.</span>
<span class="c1">#</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
   <span class="kn">import</span> <span class="nn">pytest_helper</span>
   <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">([</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;../test2/test_var_set.py&quot;</span><span class="p">],</span>
                            <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Regular imports and program code from here to the end.</span>
<span class="c1">#</span>

<span class="n">code_var</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Using pytest-helper inside a separate test file.</strong></p>
<blockquote>
<div><p>In this example there is a separate file, containing only tests, which when
run as a script executes pytest on itself.  This file is assumed to be
inside a test subdirectory, and imports the file <code class="code docutils literal notranslate"><span class="pre">do_things.py</span></code> from its
parent directory.  That directory is added to Python’s <code class="code docutils literal notranslate"><span class="pre">sys.path</span></code> by a call
to <code class="code docutils literal notranslate"><span class="pre">sys_path</span></code> (the test directory is not in the package of the parent
directory, since it is usually not recommended to have an <code class="code docutils literal notranslate"><span class="pre">__init__.py</span></code> file
in test directories).  The test file below can still be run from other files
with <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> or via the usual invocation of pytest from the command
line.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest_helper</span>

<span class="c1">#</span>
<span class="c1"># Run the test file with pytest when invoked as a script.</span>
<span class="c1">#</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="n">self_test</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Put calls to these pytest_helper functions AFTER the script_run call.</span>
<span class="c1">#</span>

<span class="n">pytest_helper</span><span class="o">.</span><span class="n">autoimport</span><span class="p">()</span>  <span class="c1"># Do some basic imports automatically.</span>

<span class="n">pytest_helper</span><span class="o">.</span><span class="n">sys_path</span><span class="p">(</span><span class="n">add_parent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># pytest_helper.sys_path(&quot;..&quot;)  # Does the same thing as the line above.</span>
<span class="c1"># pytest_helper.sys_path([&quot;..&quot;])  # Does the same as the two lines above.</span>

<span class="c1">#</span>
<span class="c1"># Test code below.</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">do_things</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c1"># Since we&#39;re testing this module, import all.</span>

<span class="nd">@fixture</span>
<span class="k">def</span> <span class="nf">my_fixture</span><span class="p">():</span>
    <span class="n">fixture_var</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
    <span class="n">locals_to_globals</span><span class="p">()</span>  <span class="c1"># Copies fixture_var to the module&#39;s global namespace.</span>

<span class="k">def</span> <span class="nf">test_var</span><span class="p">(</span><span class="n">my_fixture</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">code_var</span> <span class="o">==</span> <span class="s2">&quot;foo&quot;</span>  <span class="c1"># Assumed to be set in do_things.py.</span>
    <span class="k">assert</span> <span class="n">fixture_var</span> <span class="o">==</span> <span class="s2">&quot;bar&quot;</span>  <span class="c1"># Now in the module&#39;s global namespace.</span>
    <span class="n">test_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="n">raises</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span> <span class="n">test_dict</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="c1"># The raises function was autoimported.</span>

<span class="k">def</span> <span class="nf">test_skipped</span><span class="p">():</span>
    <span class="n">skip</span><span class="p">()</span>  <span class="c1"># The skip function was also autoimported.</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<p>Notice from these examples that very little needs to be changed in order to
extract a separate test module from the testing part of a module which
initially contains its own tests (like in the first example, in the
<a class="reference internal" href="#introduction"><span class="std std-ref">Introduction</span></a>).  You would basically do the following:</p>
<ol class="arabic simple">
<li><p>Copy the Python file to the test directory with a new name.</p></li>
<li><p>Delete the code from one file and delete the tests from the other.  (Both
still need to import pytest-helper if they use any of the helper functions.)</p></li>
<li><p>Add an import statement in the test file to import what it needs from the
code file.  If necessary, <code class="code docutils literal notranslate"><span class="pre">sys_path</span></code> can be called in the test file so
that it can find the module or package to import.</p></li>
<li><p>Change the pathname on the <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> call in the code file to point to
the new test file.  If desired, a self-testing <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> call can also be
added to the test file.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is traditional to run tests from the end of a Python module, but
<code class="code docutils literal notranslate"><span class="pre">script_run</span></code> is calling another program (pytest) to extract and run the
tests.  The test functions themselves can be placed anywhere, but it is not
recommended to place a <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> call near the end of a module.  In many
cases it works, but it causes problems with explicit relative imports.
Putting the <code class="code docutils literal notranslate"><span class="pre">script_run</span></code> call near the end of the module is also less
efficient, since the module’s initialization code gets run twice.</p>
</div>
</div>
<div class="section" id="configuration-files">
<span id="configuration"></span><h2>Configuration files<a class="headerlink" href="#configuration-files" title="Permalink to this headline">¶</a></h2>
<p>Several of the pytest-helper functions have arguments which can be overridden
by values in a configuration file.  The file must be named <code class="code docutils literal notranslate"><span class="pre">pytest_helper.ini</span></code>,
and each module separately searches for and parses a file with that name
The files are cached by filename, so each one is only read once.
Config files are loaded per-module (since many different modules across
different packages may import and use the pytest-helper functions).</p>
<p>The search is conducted from the directory of the module up to the root
directory, taking the first such file encountered.  Locating and using config
files can be disabled altogether by passing the argument <code class="code docutils literal notranslate"><span class="pre">conf=False</span></code> to the
<code class="code docutils literal notranslate"><span class="pre">init</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest_helper</span>
<span class="n">init</span><span class="p">(</span><span class="n">conf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Below is an example <code class="code docutils literal notranslate"><span class="pre">pytest_helper.ini</span></code> configuration, which sets a value for
all the options which are currently settable from the config file.  These are
only examples, not the default options.  Any other sections of the file or
other options are silently ignored.  Most of the option names are constructed
from the name of the pytest-helper function concatenated with the name of the
parameter of the function which they override.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[pytest_helper]</span>

<span class="c1"># A comment.</span>

<span class="na">script_run_pytest_args</span> <span class="o">=</span> <span class="s">&quot;-v -s&quot; # These override any pytest_args setting.</span>
<span class="na">script_run_extra_pytest_args</span> <span class="o">=</span> <span class="s">&quot;-v -s&quot; # Appended to pytest_args setting.</span>

<span class="na">autoimport_noclobber</span> <span class="o">=</span> <span class="s">False</span>
<span class="na">autoimport_skip</span> <span class="o">=</span> <span class="s">[&quot;pytest&quot;, &quot;locals_to_globals&quot;]</span>
</pre></div>
</div>
</div>
<div class="section" id="package-contents">
<h2>Package contents<a class="headerlink" href="#package-contents" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pytest_helper.html">pytest_helper package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pytest_helper.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="pytest_helper.pytest_helper_main.html">pytest_helper_main module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pytest_helper.pytest_helper_main.html#description">Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="pytest_helper.pytest_helper_main.html#functions-to-help-with-running-tests">Functions to help with running tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="pytest_helper.pytest_helper_main.html#functions-to-help-in-writing-tests">Functions to help in writing tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="pytest_helper.pytest_helper_main.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pytest_helper.global_settings.html">global_settings module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pytest_helper.global_settings.html#description">Description</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pytest_helper.config_file_handler.html">config_file_handler module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pytest_helper.config_file_handler.html#description">Description</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pytest_helper.html#module-pytest_helper">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pytest-helper</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#functions-to-help-in-running-tests">Functions to help in running tests</a></li>
<li><a class="reference internal" href="#functions-to-help-in-writing-tests">Functions to help in writing tests</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#configuration-files">Configuration files</a></li>
<li><a class="reference internal" href="#package-contents">Package contents</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

  <h4>Next topic</h4>
  <p class="topless"><a href="pytest_helper.html"
                        title="next chapter">pytest_helper package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pytest_helper.html" title="pytest_helper package"
             >next</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">pytest-helper  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>