#!albNotes

This file is about how to get fixtures (test routine setups) and the test
routines themselves to automatically share the same namespace as if they
were written in one contiguous block.  As it is now, they each have their
own function namespace.  Tricks have to be used to get them to share the
same one.

How to automate the namespace of fixtures?
0) write all init vars to function scope (will persist...bad)
1) return name of fun from fixture
2) in test fun first line, call a function (defined in each test module, simple)
   to transfer them all to local function scope

We know the name of the fun inside fixture, but not the name of the test fun
inside the init (to copy over values to from there).
 
From a fun just before return you could write all variables to module scope
if you know the name of the module or class or can look it up (you can).
You could define a function called ret to use instead of return which does
that (it has to look up both scopes and do the transfer).  To clean up,
though, you would need to use some teardown routine to unassign them.
Also, you would need to check for collisions since module scope might have
something in use.

Maybe simplest: declare a class and write everything in the fixture to the
class.  Return the class, and use that as a namespace.  Still ugly.

How about: init calls method of class TransferVars just before it returns.
That saves all locals.  Then, test fun calls another method of TransferVars
to make references to all the variable in the local scope.

Note that it should be easy to define a function that writes to the global
scope, assuming some kind of modified return statement is used at the
end.  It would just look up the functions's current scope and the module
scope and make references to everything.... we could even create a
decorator and require that
this return function be an argument to the decorated function.  It could even
remember what it copied in order to clean it up with another call!!!!

@copy_locals_to_global_scope
def test_fun(ret_fun):

No, it still has to be called somewhere inside the function, so just do
that.  Define a call for inside to copy outside.  Note it can access both
its enclosing module and its function name and local scope.

def test_fun():
    ...
    copy_locals_to_global_scope()
    return

When the function runs it can access the name of the calling function, and
use that as the key in a global dict to remember what it copied so we could
call a teardown function with clear_locals_to_global(fun_name).


How about if you run a function that copies its locals to the calling
function's local scope????  Even better, maybe.  Then just ignore the
pytest fixture stuff, call some init function that does that at the end,
and run your tests.  They all go out of scope after the function returns.

def init_egg_tests():
    ...
    copy_locals_to_calling()
    return

def test_egg():
    init_egg_tests()
    ...


One other approach: everything writes to a shared namespace which is
in module scope. Just declare in module scope a class like:
    class n(object): pass
Then
    n.egg = "egg"
    print(n.egg)
Some of this can be hidden in a few function calls, but still have to
access from the dotted prefix.

What about a beginning line of test fun that runs a setup program
which itself then calls the test fun (and skips itself the second
time)?  Then at least the test fun sees the local scope of the 
setup function, without polluting global and without needing
cleanup.  It can't modify them, though.


Call setup from test, and return locals(), that should preserve all the locals!
Then just assign everything local in an actual command (not function call).
Use the exec stuff in locals(), or maybe just assign to locals if it will
let you.


